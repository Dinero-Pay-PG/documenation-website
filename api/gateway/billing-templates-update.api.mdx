---
id: billing-templates-update
title: "Update a billing template by ID."
description: "Update a billing template by ID."
sidebar_label: "Update a billing template by ID."
hide_title: true
hide_table_of_contents: true
api: {"operationId":"billing_templates_update","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"description":"BillingTemplate generates Purchase objects, either to issue one-time invoices or in a subscription.\n\nIt does so by copying over its' `PurchaseDetails`, one of its `BillingTemplateClient`-s and generating other fields from BillingTemplate's fields as necessary into a new `Purchase` object.\n\nIf `is_subscription` is `true`, it is considered to be a subscription's BillingTemplate. You will need to specify `subscription_*` fields like `subscription_period` when creating it and add BillingTemplateClient objects to its billing cycle (`POST /billing_templates/{id}/add_subscriber/`). After that the clients will receive recurring invoices (that will be paid for automatically if client saves their card) according to the BillingTemplate settings you have specified.\n\nIf `is_subscription` is `false`, this BillingTemplate is used to send one-time invoices. After creating it and specifying `invoice_*` fields, use `POST /billing_templates/{id}/send_invoice/` request to send the actual invoices. BillingTemplateClients for non-subscription BillingTemplates are not saved.","required":["purchase","is_subscription"],"properties":{"purchase":{"description":"Core information about the Purchase, including the products, total, currency and invoice fields. If you're using invoicing via `/billing/` or `/billing_templates/`, this object will be copied 1:1 from BillingTemplate you specify to the resulting Purchases (also to subscription Purchases).","required":["products"],"properties":{"currency":{"type":"string","maxLength":3,"format":"ISO 4217","description":"Currency code in the ISO 4217 standard (e.g. 'EUR')."},"products":{"type":"array","minItems":1,"description":"Line items of the invoice. In case of a transaction with no invoice sent, specify a single Product forming the cost of transaction.","items":{"required":["name","price"],"properties":{"name":{"type":"string","maxLength":256,"description":"Product name"},"quantity":{"type":"string","format":"float","minimum":0,"default":1,"description":"Quantity of these products in invoice"},"price":{"minimum":0,"description":"You can use this field or `total_override` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"discount":{"minimum":0,"description":"Total discount per this product in invoice","default":0,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"tax_percent":{"type":"string","format":"float","minimum":0,"maximum":100,"default":0,"description":"Percent of tax added to the price of this product"},"category":{"type":"string","maxLength":256,"description":"Product category"}}}},"total":{"readOnly":true,"x-summary":"Calculated from `products`. You don't need to specify it.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"language":{"x-summary":"Language of invoice/payment forms.","type":"string","format":"ISO 639-1","maxLength":2,"description":"Language code in the ISO 639-1 format (e.g. 'en')","default":"Default value is controlled in Company -> Brand section of merchant portal separately per each Brand used (default value, if no changes are made, is `en`). Brand to be used with corresponding Purchase/BillingTemplate specified using brand_id."},"notes":{"x-summary":"Invoice notes.","type":"string","maxLength":10000},"debt":{"default":0,"x-summary":"Will be added/substracted to the invoice total, if present.","x-minValue":"`total` * -1","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"subtotal_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the grand subtotal. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_tax_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total tax. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_discount_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total discount. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total (unlike the rest of `total_*_override` fields).\n\nYou can use this field or `products[].total` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"request_client_details":{"type":"array","description":"ClientDetails fields to request from the client before the payment. If a value is passed for a field in ClientDetails, it will be automatically removed from this list.","default":[],"uniqueItems":true,"items":{"type":"string","enum":["email","phone","full_name","personal_code","brand_name","legal_name","registration_number","tax_number","bank_account","bank_code","billing_address","shipping_address"]}},"timezone":{"type":"string","format":"TZ database name","description":"Timezone to localize invoice-specific timestamps in, e.g. to display a concrete date for a `due` timestamp on the invoice.","example":"Europe/Oslo"},"due_strict":{"type":"boolean","default":false,"description":"Whether to permit payments when Purchase's `due` has passed. By default those are permitted (and status will be set to `overdue` once `due` moment is passed). If this is set to `true`, it won't be possible to pay for an overdue invoice, and when `due` is passed the Purchase's status will be set to `expired`."},"email_message":{"type":"string","readOnly":true,"maxLength":256,"description":"An optional message to display to your customer in invoice email, e.g. \"Your invoice for June\"."}}},"company_id":{"type":"string","format":"uuid","readOnly":true},"is_test":{"type":"boolean","readOnly":true,"description":"Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode."},"user_id":{"type":"string","format":"uuid","nullable":true,"readOnly":true,"description":"ID of user who has created this object in the Billing UI, if applicable."},"brand_id":{"type":"string","format":"uuid","description":"ID of the brand to create this BillingTemplate for. You can copy it down in the API section, see the \"specify the ID of the Brand\" link in answer to \"How to setup payments on website or in mobile app?\"."},"title":{"type":"string","maxLength":256},"is_subscription":{"type":"boolean","description":"Defines whether this BillingTemplate issues invoices in a recurring manner - it's a subscription - or it sends invoices only once. You can't change this parameter when you edit the BillingTemplate. If this field is `true`, you will need to specify `subscription_*` fields and `invoice_*` fields are read-only, and vice-versa."},"invoice_issued":{"nullable":true,"description":"Sets `issued` on the Purchase objects generated. Generated from current day in `purchase.timezone` if not provided. Read-only if `is_subscription == true`.","allOf":[{"type":"string","format":"ISO 8601 (YYYY-MM-DD)","example":"2020-04-30"}]},"invoice_due":{"nullable":true,"description":"Sets `due` on the Purchase objects generated. Required if `is_subscription == false`, read-only otherwise.","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"invoice_skip_capture":{"type":"boolean","default":false,"description":"Sets `skip_capture` on the Purchase objects generated. `false` by default. Read-only if `is_subscription == true`."},"invoice_send_receipt":{"type":"boolean","default":false,"description":"Sets `send_receipt` on the Purchase objects generated. `true` by default (unlike in Purchases API, where by default receipts are not sent). Read-only if `is_subscription == true`."},"subscription_period":{"description":"Defines how often are the subscription Purchases generated. Used together with `subscription_period_units`: to issue Purchases once a month, use `\"...period\": 1` and `\"...period_units\" == \"months\"`. \n\nVariable number of days in a month is respected; e.g. if subscription has a period of 1 month, a client had its billing cycle activated on January 30 and there are 28 days in February that year - billing scheduled for February will happen on 28th.\n\nBoth fields are required when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; they are read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"integer","minimum":1,"maximum":256,"default":1},"subscription_period_units":{"description":"See `subscription_period`.","default":"months","allOf":[{"type":"string","enum":["days","weeks","months"]}]},"subscription_due_period":{"description":"Used to generate `due` on the Purchase objects generated. Used together with `subscription_due_period_units`: to set the final `Purchase.due` to a week after it's generated/invoice is sent, use `\"...period\": 1` and `\"...period_units\" == \"weeks\". Required if `is_subscription == true`, read-only otherwise.","type":"integer","minimum":1,"maximum":256,"default":7},"subscription_due_period_units":{"description":"See `subscription_due_period`.","default":"days","allOf":[{"type":"string","enum":["days","weeks","months"]}]},"subscription_charge_period_end":{"description":"If this is `true`, clients are charged at the end of billing periods, and vice-versa. E.g. if you add a subscriber client to a BillingTemplate, with this value being set to `false`, he will receive first invoice today, otherwise - after a single billing period (defined by `subscription_period`/`subscription_period_units`) passes. \n\nRequired when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"boolean","default":false},"subscription_trial_periods":{"description":"How many trial periods to give the client prior to starting his billing cycle. If billing period is 1 month and you set this value to 2, subscription will automatically adjust to giving your client 2 months without payments and then charging him for the 3rd month (when exactly depends on `subscription_charge_period_end`: 3 months after the subscriber was launched for `false`, 4 for `true`). `\"subscription_trial_periods\": 0` disables this feature. \n\nRequired when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"integer","minimum":0,"maximum":256,"default":0},"subscription_active":{"description":"Whether this subscription is paused. Has the same effect as setting `\"status\": \"subscription_paused\"` for every BillingTemplateClient launched for this subscription, see the description of `status` on BillingTemplateClient for more details.\n\nIgnored (read-only) if `is_subscription == false`.","type":"boolean","default":false},"subscription_has_active_clients":{"description":"If this is `true`, there were launched clients (`POST /billing_templates/{id}/add_subscriber/` - or subscribers that were added via the gateway system UI) for this subscription.\n\nWhile this is `false` (it will be as long as you're only just created the template and haven't launched any subscribers), you can edit all of `subscription_*` fields. \n\nIf this is `true`, you're only allowed to edit `subscription_due_period`, `subscription_due_period_units` and `subscription_active`. \n\nIs always `false` if `is_subscription == false`.","type":"boolean","readOnly":true},"force_recurring":{"type":"boolean","default":false,"description":"If the used payment method supports recurring payment functionality, forces the customer's payment credentials to be saved for possible later recurring payments, without giving the customer a choice in the matter."}},"allOf":[{"type":"object","properties":{"type":{"type":"string","readOnly":true,"description":"Object type identifier"},"id":{"type":"string","format":"uuid","readOnly":true},"created_on":{"readOnly":true,"description":"Object creation time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"updated_on":{"readOnly":true,"description":"Object last modification time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]}}}]}}}},"400":{"description":"Invalid data submitted or request processing error","content":{"application/json":{"schema":{"type":"object","example":"{\n  \"__all__\": {\n    \"message\": \"descriptive error message\",\n    \"code\": \"error_code\"\n  }\n}\n"}}}},"404":{"description":"No such object"}},"requestBody":{"required":true,"content":{"application/json":{"schema":{"description":"BillingTemplate generates Purchase objects, either to issue one-time invoices or in a subscription.\n\nIt does so by copying over its' `PurchaseDetails`, one of its `BillingTemplateClient`-s and generating other fields from BillingTemplate's fields as necessary into a new `Purchase` object.\n\nIf `is_subscription` is `true`, it is considered to be a subscription's BillingTemplate. You will need to specify `subscription_*` fields like `subscription_period` when creating it and add BillingTemplateClient objects to its billing cycle (`POST /billing_templates/{id}/add_subscriber/`). After that the clients will receive recurring invoices (that will be paid for automatically if client saves their card) according to the BillingTemplate settings you have specified.\n\nIf `is_subscription` is `false`, this BillingTemplate is used to send one-time invoices. After creating it and specifying `invoice_*` fields, use `POST /billing_templates/{id}/send_invoice/` request to send the actual invoices. BillingTemplateClients for non-subscription BillingTemplates are not saved.","required":["purchase","is_subscription"],"properties":{"purchase":{"description":"Core information about the Purchase, including the products, total, currency and invoice fields. If you're using invoicing via `/billing/` or `/billing_templates/`, this object will be copied 1:1 from BillingTemplate you specify to the resulting Purchases (also to subscription Purchases).","required":["products"],"properties":{"currency":{"type":"string","maxLength":3,"format":"ISO 4217","description":"Currency code in the ISO 4217 standard (e.g. 'EUR')."},"products":{"type":"array","minItems":1,"description":"Line items of the invoice. In case of a transaction with no invoice sent, specify a single Product forming the cost of transaction.","items":{"required":["name","price"],"properties":{"name":{"type":"string","maxLength":256,"description":"Product name"},"quantity":{"type":"string","format":"float","minimum":0,"default":1,"description":"Quantity of these products in invoice"},"price":{"minimum":0,"description":"You can use this field or `total_override` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"discount":{"minimum":0,"description":"Total discount per this product in invoice","default":0,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"tax_percent":{"type":"string","format":"float","minimum":0,"maximum":100,"default":0,"description":"Percent of tax added to the price of this product"},"category":{"type":"string","maxLength":256,"description":"Product category"}}}},"total":{"readOnly":true,"x-summary":"Calculated from `products`. You don't need to specify it.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"language":{"x-summary":"Language of invoice/payment forms.","type":"string","format":"ISO 639-1","maxLength":2,"description":"Language code in the ISO 639-1 format (e.g. 'en')","default":"Default value is controlled in Company -> Brand section of merchant portal separately per each Brand used (default value, if no changes are made, is `en`). Brand to be used with corresponding Purchase/BillingTemplate specified using brand_id."},"notes":{"x-summary":"Invoice notes.","type":"string","maxLength":10000},"debt":{"default":0,"x-summary":"Will be added/substracted to the invoice total, if present.","x-minValue":"`total` * -1","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"subtotal_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the grand subtotal. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_tax_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total tax. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_discount_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total discount. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total (unlike the rest of `total_*_override` fields).\n\nYou can use this field or `products[].total` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"request_client_details":{"type":"array","description":"ClientDetails fields to request from the client before the payment. If a value is passed for a field in ClientDetails, it will be automatically removed from this list.","default":[],"uniqueItems":true,"items":{"type":"string","enum":["email","phone","full_name","personal_code","brand_name","legal_name","registration_number","tax_number","bank_account","bank_code","billing_address","shipping_address"]}},"timezone":{"type":"string","format":"TZ database name","description":"Timezone to localize invoice-specific timestamps in, e.g. to display a concrete date for a `due` timestamp on the invoice.","example":"Europe/Oslo"},"due_strict":{"type":"boolean","default":false,"description":"Whether to permit payments when Purchase's `due` has passed. By default those are permitted (and status will be set to `overdue` once `due` moment is passed). If this is set to `true`, it won't be possible to pay for an overdue invoice, and when `due` is passed the Purchase's status will be set to `expired`."},"email_message":{"type":"string","readOnly":true,"maxLength":256,"description":"An optional message to display to your customer in invoice email, e.g. \"Your invoice for June\"."}}},"company_id":{"type":"string","format":"uuid","readOnly":true},"is_test":{"type":"boolean","readOnly":true,"description":"Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode."},"user_id":{"type":"string","format":"uuid","nullable":true,"readOnly":true,"description":"ID of user who has created this object in the Billing UI, if applicable."},"brand_id":{"type":"string","format":"uuid","description":"ID of the brand to create this BillingTemplate for. You can copy it down in the API section, see the \"specify the ID of the Brand\" link in answer to \"How to setup payments on website or in mobile app?\"."},"title":{"type":"string","maxLength":256},"is_subscription":{"type":"boolean","description":"Defines whether this BillingTemplate issues invoices in a recurring manner - it's a subscription - or it sends invoices only once. You can't change this parameter when you edit the BillingTemplate. If this field is `true`, you will need to specify `subscription_*` fields and `invoice_*` fields are read-only, and vice-versa."},"invoice_issued":{"nullable":true,"description":"Sets `issued` on the Purchase objects generated. Generated from current day in `purchase.timezone` if not provided. Read-only if `is_subscription == true`.","allOf":[{"type":"string","format":"ISO 8601 (YYYY-MM-DD)","example":"2020-04-30"}]},"invoice_due":{"nullable":true,"description":"Sets `due` on the Purchase objects generated. Required if `is_subscription == false`, read-only otherwise.","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"invoice_skip_capture":{"type":"boolean","default":false,"description":"Sets `skip_capture` on the Purchase objects generated. `false` by default. Read-only if `is_subscription == true`."},"invoice_send_receipt":{"type":"boolean","default":false,"description":"Sets `send_receipt` on the Purchase objects generated. `true` by default (unlike in Purchases API, where by default receipts are not sent). Read-only if `is_subscription == true`."},"subscription_period":{"description":"Defines how often are the subscription Purchases generated. Used together with `subscription_period_units`: to issue Purchases once a month, use `\"...period\": 1` and `\"...period_units\" == \"months\"`. \n\nVariable number of days in a month is respected; e.g. if subscription has a period of 1 month, a client had its billing cycle activated on January 30 and there are 28 days in February that year - billing scheduled for February will happen on 28th.\n\nBoth fields are required when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; they are read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"integer","minimum":1,"maximum":256,"default":1},"subscription_period_units":{"description":"See `subscription_period`.","default":"months","allOf":[{"type":"string","enum":["days","weeks","months"]}]},"subscription_due_period":{"description":"Used to generate `due` on the Purchase objects generated. Used together with `subscription_due_period_units`: to set the final `Purchase.due` to a week after it's generated/invoice is sent, use `\"...period\": 1` and `\"...period_units\" == \"weeks\". Required if `is_subscription == true`, read-only otherwise.","type":"integer","minimum":1,"maximum":256,"default":7},"subscription_due_period_units":{"description":"See `subscription_due_period`.","default":"days","allOf":[{"type":"string","enum":["days","weeks","months"]}]},"subscription_charge_period_end":{"description":"If this is `true`, clients are charged at the end of billing periods, and vice-versa. E.g. if you add a subscriber client to a BillingTemplate, with this value being set to `false`, he will receive first invoice today, otherwise - after a single billing period (defined by `subscription_period`/`subscription_period_units`) passes. \n\nRequired when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"boolean","default":false},"subscription_trial_periods":{"description":"How many trial periods to give the client prior to starting his billing cycle. If billing period is 1 month and you set this value to 2, subscription will automatically adjust to giving your client 2 months without payments and then charging him for the 3rd month (when exactly depends on `subscription_charge_period_end`: 3 months after the subscriber was launched for `false`, 4 for `true`). `\"subscription_trial_periods\": 0` disables this feature. \n\nRequired when creating a BillingTemplate with `is_subscription == true`/editing a BillingTemplate with `is_subscription == true` as long as there aren't any launched subscribers; read-only otherwise, whether it's BillingTemplate's editing when there already are clients activated or if `is_subscription == false`.","type":"integer","minimum":0,"maximum":256,"default":0},"subscription_active":{"description":"Whether this subscription is paused. Has the same effect as setting `\"status\": \"subscription_paused\"` for every BillingTemplateClient launched for this subscription, see the description of `status` on BillingTemplateClient for more details.\n\nIgnored (read-only) if `is_subscription == false`.","type":"boolean","default":false},"subscription_has_active_clients":{"description":"If this is `true`, there were launched clients (`POST /billing_templates/{id}/add_subscriber/` - or subscribers that were added via the gateway system UI) for this subscription.\n\nWhile this is `false` (it will be as long as you're only just created the template and haven't launched any subscribers), you can edit all of `subscription_*` fields. \n\nIf this is `true`, you're only allowed to edit `subscription_due_period`, `subscription_due_period_units` and `subscription_active`. \n\nIs always `false` if `is_subscription == false`.","type":"boolean","readOnly":true},"force_recurring":{"type":"boolean","default":false,"description":"If the used payment method supports recurring payment functionality, forces the customer's payment credentials to be saved for possible later recurring payments, without giving the customer a choice in the matter."}},"allOf":[{"type":"object","properties":{"type":{"type":"string","readOnly":true,"description":"Object type identifier"},"id":{"type":"string","format":"uuid","readOnly":true},"created_on":{"readOnly":true,"description":"Object creation time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"updated_on":{"readOnly":true,"description":"Object last modification time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]}}}]}}}},"tags":["Billing"],"description":"Update a billing template by ID.","parameters":[{"name":"id","required":true,"in":"path","description":"Object ID (UUID)","schema":{"type":"string","format":"uuid"}}],"method":"put","path":"/billing_templates/{id}/","servers":[{"url":"/api/v1"}],"jsonRequestBodyExample":{},"info":{"title":"Public REST API","version":"v1","description":"All the endpoints below have a prefix of `https://gate.dineropay.com/api/v1/` (e.g. `POST https://gate.dineropay.com/api/v1/purchases/`).\n\nYou will need your API key that you can obtain in the Developers section in your account. Please use this key as a bearer token in the Authorization header included in every request: `Authorization: Bearer <secret key>`.\n\nBefore starting the development, we recommend checking out the list of ready-to-go connectors to the popular platforms we’ve already built for you. It might save you some precious time if you use one of these to develop your project.\n\nPlugins: [WooCommerce](https://gate.dineropay.com/apis/plugins/WooCommerce%20v3.5+), [OpenCart](https://gate.dineropay.com/apis/plugins/OpenCart%20v3.0+), [Magento](https://gate.dineropay.com/apis/plugins/Magento%20v2.0+), [PrestaShop](https://gate.dineropay.com/apis/plugins/PrestaShop%20v1.7+)\n\n\n\nLibraries: [PHP](https://gate.dineropay.com/apis/libraries/PHP), [Java](https://gate.dineropay.com/apis/libraries/Java), [C#](https://gate.dineropay.com/apis/libraries/C%23), [Node.js](https://gate.dineropay.com/apis/libraries/Node.js)\n\nSDKs: [iOS](https://gate.dineropay.com/apis/sdks/iOS), [Android](https://gate.dineropay.com/apis/sdks/Android)\n***\n\n# Online Purchases\n\n## Prebuilt payment flow — Redirect\n\nRedirect integration allows running payments using the prebuilt payment flow.\n\nTo accept payments in your application or website via redirect, use `POST /purchases/` request to create the `Purchase` and receive the `checkout_url`. Redirect the customer to the `checkout_url` to enter their card details for processing. After the payment is processed, the system will redirect the customer back to your website (take note of `success_redirect`, `failure_redirect`).\n\n*You have three options to check payment status:*\n\n1. Use `success_callback` parameter of the `Purchase` object.\n\n2. Use `GET /purchases/<purchase_id>/` request.\n\n3. Set up a Webhook using the Developers section of your account or use Webhook API to listen to `purchase.paid`, or `purchase.payment_failure` event on your server.\n\nSetting the `skip_capture` flag to `true` allows you to separate the authentication and payment execution steps, allowing you to reserve funds on the customer's card account for some time.\n\nThis flag can also enable preauthorization capability, allowing you to save the card without a financial transaction, if possible.\n\nIf the customer agrees to store his card for future purchases, there will be an option to pay with a single click next time. To enable this, create a `Client` object for each of your clients and provide `client_id` parameter value in your Purchase creation requests.\n\nTo create a Purchase or a BillingTemplate, you must specify the `Brand ID` and `API key`. You can find both in the Developers section of your account.\n\n\n\n## Custom payment flow — Direct Post\n\nDirect post integration allows running payments through the custom payment flow.\n\nTo accept payments in your application or website, use `POST /purchases/` request to create a `Purchase`.\n\nTo capture customers card details use an HTML `<form>` hosted on your website with `method=\"POST\"` and `action` pointing to the `direct_post_url` of the transaction.\n\nYou will also need to fill the form with `<input>`'s for the fields with card details. As a result, when a customer submits their card details, it will be posted straight to our system, allowing you to customize the checkout as you wish. At the same time, your PCI DSS requirement is only raised to Self-Assessment Questionnaire (SAQ A-EP), as your system doesn't receive or process card data.\n\nFor more details, see the documentation on Purchase's `direct_post_url` field.\n\n### Tokenization & recurring payments\n\nYou can store card tokens and charge the respective cards without user interaction if the payment channel supports tokenization.\n\nWhen you pass `remember_card=on` to `direct_post_url`, the respective `Purchase`'s ID will serve as a card token. This initial `Purchase` will have the `is_recurring_token` field set to `true`.\n\nTo charge the tokenized card once again, create a new Purchase and then call the `POST /purchases/{new_purchase_id}/charge/`. In the request body, provide `\"recurring_token\": \"initial_purchase_id\"`. When the request succeeds (response code `200`), the new Purchase will become paid. The token will be persisted in the Purchase's recurring_token field.\n\nUse `\"recurring_token\": \"initial_purchase_id\"` in all the upcoming `POST /purchases/{new_purchase_id}/charge/` requests.\n\nIf you wish to delete the recurring token stored for the initial `Purchase`, use the `POST /purchases/{initial_purhcase_id}/delete_recurring_token/` request. Its `is_recurring_token` will reset to `false`. \n\n## Custom payment flow — Server-to-Server\n\nServer-to-Server (\"S2S\") integration allows running payments on the server level without direct interaction between the client’s browser or application and API.\n\nYou can build an integration that prevents payers from accessing platform resources directly. In this flow, 3D Secure implementation allows API clients to:\n\nCheck 3D Secure enrolment, and if the card is enrolled, receive ACS URL together with all the necessary params for redirection to ACS (PaReq, MD);\nRedirect the payer to the ACS system of their issuer bank;\nReceive the payer back and execute the authorization with a separate request.\n\nIf the card is not enrolled in 3D Secure, authorization will execute synchronously.\n\nPlease note that 3DSv2 which is now the industry standard is fully supported by the S2S flow. While PaReq/PaRes below are 3DSv1 parameters (replaced by creq/cres in 3DSv2 challenge), in case of 3DSv2 proxy ACS solution (where the system is accepting the cardholder navigation using 3DSv1 flow and is performing all parts of 3DSv2 verification and challenge on behalf of merchant) is implemented to maintain API compatibility for older integrations.\n\nTo accept payments in your application or website via S2S:\n\n1.  Ensure the Purchase is created as described in Custom payment flow — Direct Post. As per the Purchase's direct_post_url field description, you will need to ensure all the necessary criteria are met, including success_redirect/failure_redirect fields defined for Purchase and set to arbitrary valid URLs (they will not receive any redirects in the S2S scenario);\n2.  Implement the following request in your server code, appending \"?s2s=true\" to direct_post_url to form the resulting endpoint (you can obtain the S2S token value from your account manager):\n\n        POST {direct_post_url}?s2s=true\n\n    Specify the following headers:\n\n        Content-Type: application/json\n        Authorization: Bearer {S2S token}\n\n    In the request body, provide the following data in JSON (you can omit some of the fields, then system will use default values; We recommend providing correct values from the user’s browser as it can affect 3D Secure success rate):\n\n        {\n          \"cardholder_name\": \"John Doe\",\n          \"card_number\": \"4444333322221111\",\n          \"expires\": \"01/23\",\n          \"cvc\": \"123\",\n          \"remember_card\": \"on\",\n          \"remote_ip\": \"8.8.8.8\",\n          \"user_agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\n          \"accept_header\": \"text/html\",\n          \"language\": \"en-US\",\n          \"java_enabled\": false,\n          \"javascript_enabled\": true,\n          \"color_depth\": 24,\n          \"utc_offset\": 0,\n          \"screen_width\": 1920,\n          \"screen_height\": 1080\n        }\n\n    |Field name&nbsp;|Required&nbsp;|Validation criteria/remarks&nbsp;|Default value|\n    |--- |--- |---|--- |\n    |cardholder_name|Y|Latin letters only (space and apostrophe ('), dot (.), dash (-) symbols are also allowed), max 30 characters||\n    |card_number|Y|text, digits only, no whitespace, max 19 characters||\n    |expires|Y|text in 'MM/YY' format, digits and a slash only (/^\\\\d{2}\\\\/\\\\d{2}$/), max 5 characters||\n    |cvc|Y|numeric string of 3 or 4 digits||\n    |remember_card|N|literal value \"on\" to save card, any other string otherwise||\n    |remote_ip|Y|external IP of payer’s browser in IPv4 or IPv6 format||\n    |user_agent|N|User-Agent as sent by the payer’s browser, max 2048 charge|Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 88.0.4324.96 Safari/ 537.36|\n    |accept_header|N|Same as above, max 2048 characters|text/html|\n    |language|N|Same as above, max 8 characters|en-US|\n    |java_enabled|N|boolean|false|\n    |javascript_enabled|N|boolean|true|\n    |color_depth|N|integer in 0-255 range|24|\n    |utc_offset|N|integer in -32,768 to 32,767 range|0|\n    |screen_width|N|integer in uint64 range|1920|\n    |screen_height|N|integer in uint64 range|1080|\n\n3.  If the card is not enrolled in 3S Secure, then a response will contain the field \"status\" with one of the following values:\n\"executed\" in case of a successful payment authorization;\n\"authorized\" in case fund reservation using Purchase.skip_capture was requested;\n\"error\" in case of an authorization error.\n\n    Example:\n\n        {\"status\": \"executed\"}\n\n    You will receive \"executed\" or \"authorized\" statuses with a response status code 200 and \"error\" status - with a status code of 400.\n\n    In all of those cases, it is necessary to set up webhooks for purchase events (`purchase.paid, purchase.payment_failure` at least) to receive further information about the status of the financial transaction.\n\n4.  If the card is enrolled in 3D Secure, the response will have a status code of 200, the status will be 3DS_required, and the response will contain additional fields:\n\n        {\n          \"status\": \"3DS_required\",\n          \"Method\": \"(POST|GET)\",\n          \"PaReq\": \"...\",\n          \"MD\": \"... (can arrive empty)\",\n          \"URL\": \"http://url.of.acs.bank/\",\n          \"callback_url\": \"https://...\"\n        }\n\n    It’s necessary to ensure your client’s browser makes a request with the method specified in `Method` (GET or POST only) to the ACS of issuer bank returned in \"URL\", including the values of `MD` and `PaReq` as received (use query params in case of GET and request body params in case of POST). Be aware that MD might arrive empty – in that case, you can send it further as an empty string.\n\n    In addition to those, you also **need to include the `TermUrl` parameter** in the client’s browser request, pointing to the URL in your system where the customer’s navigation will be expected. Once the payer approves the transaction, he will be redirected using the POST method to that URL with `MD` and `PaRes` params in the request body.\n\n5.  Once the client is back to `TermUrl` in your system and you have received the `MD` and `PaRes`, it’s needed to transmit them to the platform to complete the authorization. Send the following request from your server code (no auth headers required):\n\n        POST {callback_url from step 4.}\n\n        Content-Type: application/x-www-form-urlencoded\n        MD={MD received, if any}&PaRes={PaRes received}\n\n    The response will contain the authorization status in JSON format and will be identical to the format described in the previous section.\n\n## Testing Integration\n\nIt’s possible to test-drive all checkouts using a test Purchase.\n\nFor a successful payment, you can use the following card numbers:\n\n*   4444 3333 2222 1111 - non-3D Secure card\n*   5555 5555 5555 4444 - 3D Secure card\n\nFor both cards, please use:\n\n*   any cardholder name\n*   any expiry larger or equal to the current month/year\n*   CVC = 123\n\nFor a failed payment, please change the CVC or expiration date.\n\nWhen using a 3D Secure enrolled card in S2S checkout,  an incorrect CVC will trigger an authorization failure on the S2S callback step (after the customer returns from test ACS). Using a wrong expiry date emulates data validation failure and results in immediate error before that step.\n\n\n***\n\n# Billing\n\n## Invoicing\n\nTo send one-off invoices, use `POST /billing/` request. It's similar to `POST /purchases/` except that customers are an array, allowing you to bulk-issue invoices to several customers at once.\n\nTo send invoices using a template, use a separate `POST /billing_templates/` request (without `clients`!). Then, for each of your clients, use `POST /billing_templates/{billing_template_id}/send_invoice/`.\n\nIf the customer agrees to store his card for future purchases, then the next time the option to pay with a single click will appear if the payment channel supports tokenization.\n\n***\n\n## Subscriptions\n\nSubscriptions allow you to automate recurring purchases. You can create a subscription using the same request `POST /billing_templates/` as for invoices. To create a subscription billing template, specify `is_subscription: true` and `subscription_*` fields in `POST /billing_templates/` request body. Then, add subscribers using the `POST /billing_templates/<billing_template_id>/add_subscriber/` request.\n\nIf the payment channel supports tokenization and the customer agreed to store his datafor future purchases, payments will be processed automatically, while the customer will get a receipt for each purchase. Note that whenever a subscription payment fails, your customer will automatically receive an invoice he can pay (and store a new card for upcoming payments in the process). Your system will also receive the `purchase.subscription_charge_failure` webhook event, if configured.\n\nBy default, the system generates invoices and processes subscription payments at the beginning of the billing cycle.\n\nIf you want to send an invoice or charge a customer at the end of the billing cycle, just set `subscription_charge_period_end` to `true` in `POST /billing_templates/` request.\n\nThe API also provides you with an option to give a trial to your customers before enabling paid subscription period. To do that just set `subscription_trial_periods` in `POST /billing_templates/` request.\n\n***\n\n# Callbacks\n\nTwo methods for defining asynchronous callbacks are supported - `Purchase` success callbacks and webhooks.\n\n## Purchase success callbacks\n\n`Purchase` success callbacks are defined by providing a target URL in the `success_callback` field on `Purchase` creation (see [POST /purchases/](#/Purchases/purchases_create)). The system will generate a callback when:\n* a `Purchase` with `skip_capture=false` is successfully paid;\n* a `Purchase` with `skip_capture=true` is successfully captured (see [POST /purchases/{id}/capture/](#/Purchases/purchases_capture));\n* a `Purchase` is successfully paid using a recurring token (see [POST /purchases/{id}/charge/](#/Purchases/purchases_charge));\n\nThese callbacks pass a JSON-encoded `Purchase` as their payload. The payload represents a snapshot of the state of the `Purchase` when the event was created. The payload will include an `event_type` field to indicate which specific event (see [Event schema](#model-Event)) triggered the callback.\n\nThe payload is signed using a company-wide key pair. You can obtain the public key with `GET /public_key/`. See the `Authentication` section below for more details.\n\n## Webhooks\n\nFor creating and modifying webhooks, see the Webhook [CRUD API specification](#operations-tag-Webhooks).\n\n`Webhook` callback payloads are signed using a dedicated key pair. You can obtain the public key from `Webhook.public_key`. See the [Authentication](#callback-auth) section below for more details.\n\n## Delivery protocol\n\nWhen a callback is not successfully delivered (received by the target server and responded to with a 200 series HTTP response code), the system will make up to 8 additional attempts at exponentially increasing intervals between attempts. No further delivery attempts will be made if the callback is not successfully delivered 36 hours after triggering.\n\nPlease note that due to the asynchronous nature of network requests, it is possible for a callback delivery confirmation (HTTP response with a 200 series status code) to not properly arrive from the callback's target server. Therefore it is possible in case of severe network faults for the target server to receive a callback, respond to it with a 200 series HTTP status code and then receive the same callback after an interval.\n\nCallback deliveries are guaranteed to be sequential to events triggered on their source objects. For example, when registering webhooks for both the `purchase.created` and `purchase.paid` events, there will be no `purchase.paid` callbacks for this `Purchase` until all `purchase.created` callbacks for this `Purchase` are successfully delivered.\n\n## <b id=\"callback-auth\">Authentication</b>\n\nPayloads are signed using asymmetric A.K.A. public-key cryptography to guarantee the authenticity of delivered callbacks. Each callback delivery request includes an X-Signature header field. This field contains a base64-encoded RSA PKCS#1 v1.5 signature of the SHA256 digest of the request body buffer.\n\nYou can obtain the public key for `Webhook` authentication from `Webhook.public_key` of the corresponding `Webhook`.\n\nYou can obtain the public key for success callback authentication from [GET /public_key/](#operations-Public_Key-public_key).\n\nPlease note the provider is not responsible for any financial losses incurred due to not implementing payload signature verification.\n"},"postman":{"name":"Update a billing template by ID.","description":{"type":"text/plain"},"url":{"path":["billing_templates",":id",""],"host":["{{baseUrl}}"],"query":[],"variable":[{"disabled":false,"description":{"content":"(Required) Object ID (UUID)","type":"text/plain"},"type":"any","value":"","key":"id"}]},"header":[{"key":"Content-Type","value":"application/json"},{"key":"Accept","value":"application/json"}],"method":"PUT","body":{"mode":"raw","raw":"\"\"","options":{"raw":{"language":"json"}}}}}
sidebar_class_name: "put api-method"
info_path: docs/petstore/public-rest-api
custom_edit_url: null
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem";
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## Update a billing template by ID.



Update a billing template by ID.

<details style={{"marginBottom":"1rem"}} data-collapsed={false} open={true}><summary style={{}}><strong>Path Parameters</strong></summary><div><ul><ParamsItem className={"paramsItem"} param={{"name":"id","required":true,"in":"path","description":"Object ID (UUID)","schema":{"type":"string","format":"uuid"}}}></ParamsItem></ul></div></details><MimeTabs><TabItem label={"application/json"} value={"application/json-schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Request Body</strong><strong style={{"fontSize":"var(--ifm-code-font-size)","color":"var(--openapi-required)"}}> required</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}></ul></details></TabItem></MimeTabs><div><ApiTabs><TabItem label={"200"} value={"200"}><div>

OK

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"type"} required={false} deprecated={undefined} schemaDescription={"Object type identifier"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"id"} required={false} deprecated={undefined} schemaDescription={undefined} schemaName={"uuid"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"created_on"} required={false} deprecated={undefined} schemaDescription={"Object creation time"} schemaName={"Unix timestamp (seconds)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"updated_on"} required={false} deprecated={undefined} schemaDescription={"Object last modification time"} schemaName={"Unix timestamp (seconds)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"type\": \"string\",\n  \"id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"created_on\": 1619740800,\n  \"updated_on\": 1619740800\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"400"} value={"400"}><div>

Invalid data submitted or request processing error

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><li><div><strong>object</strong></div></li></ul></details></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"404"} value={"404"}><div>

No such object

</div><div></div></TabItem></ApiTabs></div>
      