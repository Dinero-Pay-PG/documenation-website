---
id: purchases-delete-recurring-token
title: "Delete a recurring token associated with a purchase."
description: "Will set `is_recurring_token` to `false`. You won't be able to use this Purchase's ID as a `recurring_token` anymore. The respective ClientRecurringToken, if any, will also be deleted."
sidebar_label: "Delete a recurring token associated with a purchase."
hide_title: true
hide_table_of_contents: true
api: {"operationId":"purchases_delete_recurring_token","responses":{"200":{"description":"OK","content":{"application/json":{"schema":{"description":"Record of a single purchase operation, either a transaction originating from e-commerce integration or invoice sent. Has a status attribute, e.g. can be `created`, `paid` or `refunded`.","required":["client","purchase","brand_id"],"properties":{"client":{"description":"Either this or `.client_id` is required.","allOf":[{"description":"Contains details about the client of a purchase or payment - the remote payer/fund recipient party.","required":["email"],"properties":{"email":{"type":"string","format":"email","maxLength":254,"description":"Email address"},"phone":{"type":"string","format":"phone","maxLength":32,"description":"Phone number in the `<country_code> <number>` format","example":"+44 45643564564"},"full_name":{"type":"string","maxLength":128,"description":"Name and surname of client"},"personal_code":{"type":"string","maxLength":32,"description":"Personal identification code of client"},"street_address":{"type":"string","maxLength":128,"description":"Street house number and flat address where applicable"},"country":{"type":"string","maxLength":2,"format":"ISO 3166-1 alpha-2","description":"Country code in the ISO 3166-1 alpha-2 format (e.g. 'GB')"},"city":{"type":"string","maxLength":128,"description":"City name"},"zip_code":{"type":"string","maxLength":32,"description":"ZIP or postal code"},"state":{"type":"string","maxLength":2,"description":"State code"},"shipping_street_address":{"type":"string","maxLength":128,"description":"Street house number and flat address where applicable"},"shipping_country":{"type":"string","maxLength":2,"format":"ISO 3166-1 alpha-2","description":"Country code in the ISO 3166-1 alpha-2 format (e.g. 'GB')"},"shipping_city":{"type":"string","maxLength":128,"description":"City name"},"shipping_zip_code":{"type":"string","maxLength":32,"description":"ZIP or postal code"},"shipping_state":{"type":"string","maxLength":2,"description":"State code"},"cc":{"type":"array","items":{"type":"string","format":"email","maxLength":254,"description":"Email address"},"description":"Email addresses to receive a carbon copy of all notification emails"},"bcc":{"type":"array","items":{"type":"string","format":"email","maxLength":254,"description":"Email address"},"description":"Email addresses to receive a blind carbon copy of all notification emails"},"legal_name":{"type":"string","maxLength":128,"description":"Legal name of company"},"brand_name":{"type":"string","maxLength":128,"description":"Company brand name"},"registration_number":{"type":"string","maxLength":32,"description":"Registration number of company"},"tax_number":{"type":"string","maxLength":32,"description":"Tax payer registration number"}},"allOf":[{"type":"object","properties":{"bank_account":{"type":"string","maxLength":34,"description":"Bank account number (e.g. IBAN)"},"bank_code":{"type":"string","maxLength":11,"description":"SWIFT/BIC code of the bank"}}}]}]},"purchase":{"description":"Core information about the Purchase, including the products, total, currency and invoice fields. If you're using invoicing via `/billing/` or `/billing_templates/`, this object will be copied 1:1 from BillingTemplate you specify to the resulting Purchases (also to subscription Purchases).","required":["products"],"properties":{"currency":{"type":"string","maxLength":3,"format":"ISO 4217","description":"Currency code in the ISO 4217 standard (e.g. 'EUR')."},"products":{"type":"array","minItems":1,"description":"Line items of the invoice. In case of a transaction with no invoice sent, specify a single Product forming the cost of transaction.","items":{"required":["name","price"],"properties":{"name":{"type":"string","maxLength":256,"description":"Product name"},"quantity":{"type":"string","format":"float","minimum":0,"default":1,"description":"Quantity of these products in invoice"},"price":{"minimum":0,"description":"You can use this field or `total_override` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"discount":{"minimum":0,"description":"Total discount per this product in invoice","default":0,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"tax_percent":{"type":"string","format":"float","minimum":0,"maximum":100,"default":0,"description":"Percent of tax added to the price of this product"},"category":{"type":"string","maxLength":256,"description":"Product category"}}}},"total":{"readOnly":true,"x-summary":"Calculated from `products`. You don't need to specify it.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"language":{"x-summary":"Language of invoice/payment forms.","type":"string","format":"ISO 639-1","maxLength":2,"description":"Language code in the ISO 639-1 format (e.g. 'en')","default":"Default value is controlled in Company -> Brand section of merchant portal separately per each Brand used (default value, if no changes are made, is `en`). Brand to be used with corresponding Purchase/BillingTemplate specified using brand_id."},"notes":{"x-summary":"Invoice notes.","type":"string","maxLength":10000},"debt":{"default":0,"x-summary":"Will be added/substracted to the invoice total, if present.","x-minValue":"`total` * -1","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"subtotal_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the grand subtotal. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_tax_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total tax. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_discount_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total discount. This field is visual-only, setting it won't impact `total`.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"total_override":{"default":null,"nullable":true,"x-summary":"If specified and not null, will override the total (unlike the rest of `total_*_override` fields).\n\nYou can use this field or `products[].total` with a value of 0 to activate preauthorization scenario. See the description of the `Purchase.skip_capture` field.","allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"request_client_details":{"type":"array","description":"ClientDetails fields to request from the client before the payment. If a value is passed for a field in ClientDetails, it will be automatically removed from this list.","default":[],"uniqueItems":true,"items":{"type":"string","enum":["email","phone","full_name","personal_code","brand_name","legal_name","registration_number","tax_number","bank_account","bank_code","billing_address","shipping_address"]}},"timezone":{"type":"string","format":"TZ database name","description":"Timezone to localize invoice-specific timestamps in, e.g. to display a concrete date for a `due` timestamp on the invoice.","example":"Europe/Oslo"},"due_strict":{"type":"boolean","default":false,"description":"Whether to permit payments when Purchase's `due` has passed. By default those are permitted (and status will be set to `overdue` once `due` moment is passed). If this is set to `true`, it won't be possible to pay for an overdue invoice, and when `due` is passed the Purchase's status will be set to `expired`."},"email_message":{"type":"string","readOnly":true,"maxLength":256,"description":"An optional message to display to your customer in invoice email, e.g. \"Your invoice for June\"."}}},"payment":{"readOnly":true,"nullable":true,"allOf":[{"description":"Details of an executed transaction. Read-only for `Purchase`s and `Payout`s. For an unpaid `Purchase`, this object will be `null`.","properties":{"is_outgoing":{"type":"boolean","default":false,"description":"Denotes the direction of payment, e.g. for a paid Purchase, is granted to be `false`, `true` for payouts."},"payment_type":{"type":"string","readOnly":true,"enum":["purchase","purchase_charge","payout","bank_payment","refund","custom"]},"amount":{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."},"currency":{"type":"string","maxLength":3,"format":"ISO 4217","description":"Currency code in the ISO 4217 standard (e.g. 'EUR')."},"net_amount":{"x-summary":"Net amount of payment with all fees and pending amount subtracted. `amount` = `net_amount` + `fee_amount` + `pending_amount`. The respective account is credited or debited with this value.","readOnly":true,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"fee_amount":{"x-summary":"Amount of fees for this payment. For a Purchase's PurchaseDetails this is the calculated transaction fee.","readOnly":true,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"pending_amount":{"x-summary":"Pending amount for this payment that will be unfrozen later. If e.g. it's a Purchase's PaymentDetails and a part of transaction sum is withheld to form a rolling reserve, this field will be equal to the frozen part amount.","readOnly":true,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"pending_unfreeze_on":{"x-summary":"Informs when the `pending_amount` will be unfrozen.","readOnly":true,"nullable":true,"default":null,"allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"description":{"type":"string","maxLength":256},"paid_on":{"readOnly":true,"description":"When the payment was accepted in (`is_outgoing == false`) or sent from (`is_outgoing == true`) the gateway system.","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"remote_paid_on":{"readOnly":true,"description":"If available, this field will report the date the payment was sent by the remote payer (`is_outgoing == false`) or when funds arrived to the remote beneficiary (`is_outgoing == true`).","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]}}}]},"issuer_details":{"readOnly":true,"allOf":[{"description":"Read-only details of issuer company/brand, persisted for invoice display.","readOnly":true,"properties":{"website":{"readOnly":true,"description":"Company website URL","allOf":[{"type":"string","format":"url","maxLength":500}]},"legal_street_address":{"readOnly":true,"allOf":[{"type":"string","maxLength":128,"description":"Street house number and flat address where applicable"}]},"legal_country":{"readOnly":true,"allOf":[{"type":"string","maxLength":2,"format":"ISO 3166-1 alpha-2","description":"Country code in the ISO 3166-1 alpha-2 format (e.g. 'GB')"}]},"legal_city":{"readOnly":true,"allOf":[{"type":"string","maxLength":128,"description":"City name"}]},"legal_zip_code":{"readOnly":true,"allOf":[{"type":"string","maxLength":32,"description":"ZIP or postal code"}]},"bank_accounts":{"type":"array","readOnly":true,"items":{"type":"object","properties":{"bank_account":{"type":"string","maxLength":34,"description":"Bank account number (e.g. IBAN)"},"bank_code":{"type":"string","maxLength":11,"description":"SWIFT/BIC code of the bank"}}}},"legal_name":{"type":"string","maxLength":128,"description":"Legal name of company","readOnly":true},"brand_name":{"type":"string","maxLength":128,"description":"Company brand name","readOnly":true},"registration_number":{"type":"string","maxLength":32,"description":"Registration number of company","readOnly":true},"tax_number":{"type":"string","maxLength":32,"description":"Tax payer registration number","readOnly":true}}}]},"transaction_data":{"type":"object","description":"Payment method-specific, read-only transaction data. Will contain information about all the transaction attempts and possible errors, if available.","readOnly":true,"properties":{"payment_method":{"type":"string","description":"Payment method used if Purchase was paid, blank string otherwise."},"extra":{"type":"object","description":"Extra data associated with selected payment method if Purchase was paid, empty object otherwise. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`."},"country":{"type":"string","description":"Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if Purchase was not paid or country could not be detected."},"attempts":{"type":"array","description":"Will contain information about all the payment attempts made and errors encountered, if any.","items":{"type":"object","properties":{"type":{"type":"string","description":"Type of action attempted","enum":["execute","authorize","release","capture","recurring_execute","delete_recurring_token","refund"]},"successful":{"type":"boolean","description":"If this attempt was successful or not. For `false`, `error` of this attempt will be not null."},"payment_method":{"type":"string","description":"Payment method used for this attempt."},"extra":{"type":"object","description":"Extra data associated with selected payment method. Dataset depends on payment method. E.g. for card payment methods like `visa` or `mastercard` it will contain properties `masked_pan: string`, `three_d_secure: boolean`, `expiry_month: int`, `expiry_year: int` and `cardholder_name: string`."},"country":{"type":"string","description":"Country code (in the ISO 3166-1 alpha-2 format e.g. 'GB') where payment tool used originates (e.g. in case of card payments, the card issuing country). Will be blank if country could not be detected."},"client_ip":{"type":"string","format":"IP","description":"IP the paying client made this attempt from, if available."},"processing_time":{"description":"Time (if possible, fetched from the remot processing system) this attempt happened at.","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"error":{"type":"object","nullable":true,"description":"Code and description of the error encountered. Not-null if `successful` parameter of this attempt is `false`.","properties":{"code":{"type":"string","description":"Available error codes: \n\n---\n\n`unknown_payment_method`: Unknown payment method\n\n---\n\n`invalid_card_number`: Invalid card number\n\n---\n\n`invalid_expires`: Invalid expires\n\n---\n\n`no_matching_terminal`: No matching terminal\n\n---\n\n`blacklisted_tx`: Blacklisted transaction: blocked (general)\n\n---\n\n`timeout_3ds_enrollment_check`: 3DS enrollment check timeout\n\n---\n\n`timeout_acquirer_status_check`: Timeout checking payment status with acquirer\n\n---\n\n`validation_card_details_missing`: Card data field values are missing from request\n\n---\n\n`validation_cvc_not_provided`: `cvc` field not provided\n\n---\n\n`validation_cardholder_name_not_provided`: `cardholder_name` field not provided\n\n---\n\n`validation_card_number_not_provided`: `card_number` field not provided\n\n---\n\n`validation_expires_not_provided`: `expires` field not provided\n\n---\n\n`validation_cvc_too_long`: `cvc` is too long\n\n---\n\n`validation_cardholder_name_too_long`: `cardholder_name` is too long\n\n---\n\n`validation_card_number_too_long`: `card_number` is too long\n\n---\n\n`validation_expires_too_long`: `expires` is too long\n\n---\n\n`validation_cvc_invalid`: `cvc` is invalid\n\n---\n\n`validation_cardholder_name_invalid`: `cardholder_name` is too long or invalid\n\n---\n\n`validation_card_number_invalid`: `card_number` is invalid\n\n---\n\n`validation_expires_invalid`: `expires` is invalid\n\n---\n\n`acquirer_connection_error`: Acquirer connection error\n\n---\n\n`blacklisted_tx_issuing_country`: Blacklisted transaction: issuing country\n\n---\n\n`s2s_not_supported`: Server-to-server flow not supported by processing\n\n---\n\n`timeout`: Operation timeout\n\n---\n\n`general_transaction_error`: Unrecognized transaction error\n\n---\n\n`antifraud_general`: Decline, fraud\n\n---\n\n`acquirer_internal_error`: Acquirer internal error\n\n---\n\n`exceeds_frequency_limit`: Exceeds frequency limit\n\n---\n\n`insufficient_funds`: Insufficient funds\n\n---\n\n`purchase_already_paid_for`: Purchase is already paid for\n\n---\n\n`issuer_not_available`: Issuer Not Available\n\n---\n\n`3ds_authentication_failed`: 3DS authentication failed\n\n---\n\n`do_not_honour`: Do not honour (the transaction was declined by the Issuer without definition or reason).\n\n---\n\n`exceeds_withdrawal_limit`: Exceeds withdrawal limit\n\n---\n\n`exceeded_account_limit`: Exceeded account limit\n\n---\n\n`expired_card`: Expired card\n\n---\n\n`blacklisted_tx_risk_score`: Blacklisted transaction: risk score\n\n---\n\n`transaction_not_supported_or_not_valid_for_card`: The transaction request presented is not supported or is not valid for the card number presented.\n\n---\n\n`exceeded_acquirer_refund_amount`: Exceeded refundable amount defined by acquirer\n\n---\n\n`transaction_not_permitted_on_terminal`: Transaction not permitted on terminal (this card does not support the type of transaction requested).\n\n---\n\n`acquirer_configuration_error`: Acquirer configuration error\n\n---\n\n`transaction_not_permitted_to_cardholder`: Transaction not permitted to cardholder\n\n---\n\n`invalid_issuer_number`: No such issuer (the Issuer number is not valid).\n\n---\n\n`restricted_card`: Restricted card\n\n---\n\n`merchant_response_timeout`: Timeout of merchant response exceeded\n\n---\n\n`reconcile_error`: Reconcilation error\n\n---\n\n`lost_card`: Lost card\n\n---\n\n`stolen_card`: Stolen card\n\n---\n\n`invalid_amount`: Invalid amount\n\n---\n\n`re_enter_transaction`: Re enter transaction\n\n---\n\n`security_violation`: Security violation\n\n---\n\n`partial_forbidden`: Intervene, bank approval required for partial amount\n\n---\n\n`suspected_fraud`: Decline, suspected fraud\n\n---\n\n`acquirer_routing_error`: Acquirer routing error\n\n---\n\n`payment_rejected_other_reason`: Payment rejected (other reason)\n\n---\n\n`authorization_failed`: Payment authorization failed\n\n---\n\n`acquirer_error_cs`: Internal acquirer error. Please, contact support.\n\n---\n\n`decline_irregular_transaction_pattern`: Declined by acquirer - irregular transaction pattern, please contact support\n\n---\n\n`invalid_card_data`: Invalid card data provided\n\n---\n\n`exceeded_terminal_limit`: Exceeded terminal limit\n\n---\n\n`recurring_token_expired`: recurring token expired\n\n---\n\n`soft_decline_contact_support`: Soft Decline - Please contact support for manual settlement of this purchase\n\n---\n\n`payment_method_details_missing`: Missing payment_method_details"},"message":{"type":"string","description":"Verbose name and explanation of this error."}}}}}}}},"status":{"type":"string","description":"Purchase status. Can have the following values: \n\n`created`: Purchase was created using POST /purchases/ or Billing API capabilities.\n\n---\n\n`sent`: Invoice for this purchase was sent over email using Billing API capabilities.\n\n---\n\n`viewed`: The client has viewed the payform and/or invoice details for this purchase.\n\n---\n\n`error`: There was a failed payment attempt for this purchase because of a problem with customer's payment instrument (e.g. low account balance). You can analyze the `.transaction_data` to get information on reason of the failure.\n\n---\n\n`cancelled`: Purchase was cancelled using the `POST /purchases/{id}/cancel/` endpoint; payment for it is not possible anymore.\n\n---\n\n`overdue`: Purchase is past its' `.due`, but payment for it is still possible (unless e.g. POST /purchases/{id}/cancel/ is used).\n\n---\n\n`expired`: Purchase is past its' `.due` and payment for it isn't possible anymore (as a result of `purchase.due_strict` having been set to `true`).\n\n---\n\n`blocked`: Like `error`, but payment attempt was blocked due to fraud scoring below threshold or other security checks not passing.\n\n---\n\n`hold`: Funds are on hold for this Purchase (`.skip_capture: true` was used). You can now run `POST /capture/` or `POST /release/` for this payment to capture the payment or return funds to the client, respectively.\n\n---\n\n`released`: This Purchase previously had `hold` status, but funds have since been released and returned to the customer's card.\n\n---\n\n`pending_release`: release of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/release/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`pending_capture`: capture of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/capture/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`preauthorized`: A preauthorization of a card (authorization of card data without a financial transaction) was executed successfully using this Purchase. See the description of the `.skip_capture` field for more details.\n\n---\n\n`paid`: Purchase was successfully paid for.\n\n---\n\n`pending_execute`: Payment (or `hold` in case of `skip_capture`) for this Purchase is in processing, but is not finalized on the acquirer side yet.\n\n---\n\n`pending_charge`: Recurring payment for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/charge/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`cleared`: Funds for this Purchase (that was already `paid`) have been transferred for clearing in payment card network. All non-card payment methods and some card payment methods (depends on configuration) don't use this status and Purchases paid using them stay in `paid` status instead.\n\n---\n\n`settled`: Settlement was issued for funds for this Purchase (that was already `paid`). All non-card payment methods and some card payment methods (depends on configuration) don't use this status and Purchases paid using them stay in `paid` status instead.\n\n---\n\n`chargeback`: A chargeback was registered for this, previously paid, Purchase.\n\n---\n\n`pending_refund`: a refund (full or partial) for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/refund/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`refunded`: This Purchase had its payment refunded, fully or partially.","default":"created","readOnly":true,"enum":["created","sent","viewed","error","cancelled","overdue","expired","blocked","hold","released","pending_release","pending_capture","preauthorized","paid","pending_execute","pending_charge","cleared","settled","chargeback","pending_refund","refunded"]},"status_history":{"type":"array","readOnly":true,"description":"History of status changes, latest last. Might contain entry about a related object, e.g. status change to `refunded` will contain a reference to the refund Payment.","items":{"properties":{"status":{"type":"string","description":"Purchase status. Can have the following values: \n\n`created`: Purchase was created using POST /purchases/ or Billing API capabilities.\n\n---\n\n`sent`: Invoice for this purchase was sent over email using Billing API capabilities.\n\n---\n\n`viewed`: The client has viewed the payform and/or invoice details for this purchase.\n\n---\n\n`error`: There was a failed payment attempt for this purchase because of a problem with customer's payment instrument (e.g. low account balance). You can analyze the `.transaction_data` to get information on reason of the failure.\n\n---\n\n`cancelled`: Purchase was cancelled using the `POST /purchases/{id}/cancel/` endpoint; payment for it is not possible anymore.\n\n---\n\n`overdue`: Purchase is past its' `.due`, but payment for it is still possible (unless e.g. POST /purchases/{id}/cancel/ is used).\n\n---\n\n`expired`: Purchase is past its' `.due` and payment for it isn't possible anymore (as a result of `purchase.due_strict` having been set to `true`).\n\n---\n\n`blocked`: Like `error`, but payment attempt was blocked due to fraud scoring below threshold or other security checks not passing.\n\n---\n\n`hold`: Funds are on hold for this Purchase (`.skip_capture: true` was used). You can now run `POST /capture/` or `POST /release/` for this payment to capture the payment or return funds to the client, respectively.\n\n---\n\n`released`: This Purchase previously had `hold` status, but funds have since been released and returned to the customer's card.\n\n---\n\n`pending_release`: release of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/release/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`pending_capture`: capture of funds for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/capture/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`preauthorized`: A preauthorization of a card (authorization of card data without a financial transaction) was executed successfully using this Purchase. See the description of the `.skip_capture` field for more details.\n\n---\n\n`paid`: Purchase was successfully paid for.\n\n---\n\n`pending_execute`: Payment (or `hold` in case of `skip_capture`) for this Purchase is in processing, but is not finalized on the acquirer side yet.\n\n---\n\n`pending_charge`: Recurring payment for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/charge/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`cleared`: Funds for this Purchase (that was already `paid`) have been transferred for clearing in payment card network. All non-card payment methods and some card payment methods (depends on configuration) don't use this status and Purchases paid using them stay in `paid` status instead.\n\n---\n\n`settled`: Settlement was issued for funds for this Purchase (that was already `paid`). All non-card payment methods and some card payment methods (depends on configuration) don't use this status and Purchases paid using them stay in `paid` status instead.\n\n---\n\n`chargeback`: A chargeback was registered for this, previously paid, Purchase.\n\n---\n\n`pending_refund`: a refund (full or partial) for this Purchase is in processing, but is not finalized on the acquirer side yet. Is set by `POST /purchases/{id}/refund/` operation when it takes longer than expected to process on the acquirer side.\n\n---\n\n`refunded`: This Purchase had its payment refunded, fully or partially.","default":"created","readOnly":true,"enum":["created","sent","viewed","error","cancelled","overdue","expired","blocked","hold","released","pending_release","pending_capture","preauthorized","paid","pending_execute","pending_charge","cleared","settled","chargeback","pending_refund","refunded"]},"timestamp":{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800},"related_object":{"nullable":true,"properties":{"type":{"type":"string"},"id":{"type":"string","format":"uuid"}}}}}},"viewed_on":{"description":"Time the payment form or invoice page was first viewed on","readOnly":true,"nullable":true,"allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"company_id":{"type":"string","format":"uuid","readOnly":true},"is_test":{"type":"boolean","readOnly":true,"description":"Indicates this is a test object, created using test API keys or using Billing section of UI while in test mode."},"user_id":{"type":"string","format":"uuid","nullable":true,"readOnly":true,"description":"ID of user who has created this object in the Billing UI, if applicable."},"brand_id":{"type":"string","format":"uuid","description":"ID of the brand to create this Purchase for. You can copy it down in the API section, see the \"specify the ID of the Brand\" link in answer to \"How to setup payments on website or in mobile app?\"."},"billing_template_id":{"type":"string","format":"uuid","nullable":true,"readOnly":true,"description":"ID of a BillingTemplate that has spawned this Purchase, if any."},"client_id":{"type":"string","format":"uuid","nullable":true,"default":null,"description":"ID of a Client object used to initialize ClientDetails (`.client`) of this Purchase. Either this field or specifying `.client` object is required (you can only specify a value for one of these fields). All `ClientDetails` fields from the Client will be copied to `.client` object. Note that editing Client object won't change the respective fields in already created Purchases. \n\nIf you specify this field and your client saves a `recurring_token` (for instance, by saving their card), the respective ClientRecurringToken will be created. See the `/clients/{id}/recurring_tokens/` endpoint."},"send_receipt":{"type":"boolean","default":false,"description":"Whether to send receipt email for this Purchase when it's paid."},"is_recurring_token":{"type":"boolean","readOnly":true,"description":"Indicates whether a recurring token (e.g. for card payments - card token) was saved for this Purchase. If this is `true`, the `id` of this Purchase can be used as a `recurring_token` in `POST /purchases/{id}/charge/`, enabling you to pay for that Purchase using the same method (same card for card payments) that this one was paid with."},"recurring_token":{"type":"string","format":"uuid","readOnly":true,"nullable":true,"description":"ID of a recurring token (Purchase having `is_recurring_token == true`) that was used to pay this Purchase, if any."},"skip_capture":{"type":"boolean","default":false,"description":"Card payment-specific: if set to true, only authorize the payment (place funds on hold) when payer enters his card data and pays. This option requires a `POST /capture/` or `POST /release/` later on. \n\nYou can use the preauthorization feature if you set this parameter to true and make the Purchase with `purchase.total == 0` (this can be achieved by providing a list of `purchase.products` with a total `price` of 0, or simply overriding the total using `purchase.total_override` to 0). The resulting Purchase can only be \"paid\" by the client (only cardholder data verification will happen, without a financial transaction) by card and will enforce saving the client's card. When this happens, the Purchase will have `status` of `preauthorized` and the `purchase.preauthorized` webhook callbacks will be emitted. \n\nTrying to use skip_capture (or preauthorization) without any payment methods that support the respective actions (this can be a result of `payment_method_whitelist` field being used) will result in an error on Purchase creation request step. Please check the `GET /payment_methods/` response for your desired Purchase parameters and/or consult with your account manager."},"force_recurring":{"type":"boolean","default":false,"description":"If the used payment method supports recurring payment functionality, forces the customer's payment credentials to be saved for possible later recurring payments, without giving the customer a choice in the matter."},"reference_generated":{"type":"string","readOnly":true,"description":"If you don't provide an invoice `reference` yourself, this autogenerated value will be used as a reference instead."},"reference":{"type":"string","maxLength":128,"description":"Invoice reference."},"issued":{"description":"Value for 'Invoice issued' field. Display-only, does not get validated. If not provided, will be generated as the current date in `purchase.timezone` at the moment of Purchase's creation.","nullable":true,"allOf":[{"type":"string","format":"ISO 8601 (YYYY-MM-DD)","example":"2020-04-30"}]},"due":{"description":"When the payment is due for this Purchase. The default behaviour is to still allow payment once this moment passes. To change that, set `purchase.due_strict` to true.","nullable":true,"allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"refund_availability":{"description":"Specifies, if the purchase can be refunded fully and partially, only fully, partially or not at all.","type":"string","readOnly":true,"enum":["all","full_only","partial_only","pis_all","pis_partial","none"]},"refundable_amount":{"x-summary":"Amount available for refunds.","readOnly":true,"allOf":[{"type":"integer","description":"Amount of money as the smallest indivisible units of the currency. Examples: 1 cent for EUR and 1 Yen for JPY."}]},"currency_conversion":{"type":"object","readOnly":true,"nullable":true,"description":"This object is present when automatic currency conversion has occurred upon creation of the purchase. Purchase's original currency was changed and its original amount was converted using the exchange rate shown here.","properties":{"original_currency":{"readOnly":true,"type":"string","description":"Currency this purchase was initially created with"},"original_amount":{"readOnly":true,"type":"integer","description":"Amount this purchase was initially created with"},"exchange_rate":{"readOnly":true,"type":"number","description":"Exchanged rate that was used for currency conversion. Original amount was multiplied by this number to calculate the new purchase amount."}}},"payment_method_whitelist":{"type":"array","minItems":1,"description":"An optional whitelist of payment methods availble for this purchase. Use this field if you want to restrict your payer to pay using only one or several specific methods. \n\nUsing this field and at the same time trying to use specific capabilities of a Purchase (e.g. `skip_capture` or charging it using a saved card token using `POST /purchases/{id}/charge/`) can cause a situation when there are no payment methods available for paying this Purchase. This will cause a validation error on Purchase creation. Please check the `GET /payment_methods/` response for your desired Purchase parameters and/or consult with your account manager.","items":{"type":"string","description":"Payment method name as returned by `GET /payment_methods/`."}},"success_redirect":{"description":"When Purchase is paid for successfully, your customer will be taken to this link. Otherwise a standard screen will be displayed.","allOf":[{"type":"string","format":"url","maxLength":500}]},"failure_redirect":{"description":"If there's a payment failure for this Purchase, your customer will be taken to this link. Otherwise a standard screen will be displayed.","allOf":[{"type":"string","format":"url","maxLength":500}]},"cancel_redirect":{"description":"If you provide this link, customer will have an option to go to it instead of making payment (a button with 'Return to seller' text will be displayed). Can't contain any of the following symbols: `<>'\"` .\n\nBe aware that this does not cancel the payment (e.g. does not do the equivalent of doing the `POST /purchases/{id}/cancel/` request); the client will still be able to press 'Back' in the browser and perform the payment.","allOf":[{"type":"string","format":"url","maxLength":500}]},"success_callback":{"description":"When Purchase is paid for successfully, the `success_callback` URL will receive a POST request with the Purchase object's data in body.","allOf":[{"type":"string","format":"url","maxLength":500}]},"creator_agent":{"type":"string","maxLength":32,"description":"Identification of software (e.g. an ecommerce module and version) used to create this purchase, if any."},"platform":{"type":"string","enum":["web","api","ios","android","macos","windows"],"description":"Platform this Purchase was created on."},"product":{"type":"string","readOnly":true,"enum":["purchases","billing_invoices","billing_subscriptions","billing_subscriptions_invoice"],"description":"Defines which gateway product was used to create this Purchase."},"created_from_ip":{"type":"string","format":"IP","readOnly":true,"description":"IP the Purchase was created from."},"invoice_url":{"description":"URL you will be able to access invoice for this Purchase at, if applicable","readOnly":true,"nullable":true,"allOf":[{"type":"string","format":"url","maxLength":500}]},"checkout_url":{"description":"URL you will be able to access the checkout for this Purchase at, if payment for it is possible. When building integrations, redirect the customer to this URL once purchase is created. \n\nYou can add the `preferred` query arg to the `checkout_url` in order to force redirect the client straight to the checkout for a specific payment method (`?preferred={payment_method}`, where `{payment_method}` is the payment method name as returned by `GET /payment_methods/`). If this method redirects the client further to a different system and no customer data entry is needed on gateway's checkout page, your payer will be taken straight to that page (not seeing the gateway's checkout UI); otherwise, he will see the payment method entry UI on the gateway checkout page.","readOnly":true,"allOf":[{"type":"string","format":"url","maxLength":500}]},"direct_post_url":{"description":"URL that can be used for Direct Post integration. \n\nThis functionality is activated for each merchant account individually. Please consult with your account manager if you wish to use it. \n\nWill be null if payment for purchase is not possible, `purchase.request_client_details` isn't empty or success_redirect/failure_redirect are not provided - these all break the usual direct post flow.\n\nTo leverage Direct Post checkout, create a `<form>` having `method=\"POST\" action=\"<direct_post_url value>\"` and include the following inputs:\n\n`cardholder_name: text, Latin letters only (space and apostrophe (`'`), dot (`.`), dash (`-`) symbols are also allowed), max 30 chars`\n\n---\n\n`card_number: text, digits only, no whitespace, max 19 chars`\n\n---\n\n`expires: text in 'MM/YY' format, digits and a slash only /^\\d{2}\\/\\d{2}$/, max 5 chars`\n\n---\n\n`cvc: numeric string of 3 or 4 digits`\n\n---\n\n`remember_card: checkbox with value=\"on\" (the default when omitting value attribute of a checkbox input)`\n\nEnsure the validation as listed above! Validation errors will be treated as payment failures. Obviously, you can style this form to fit in with the rest of your website.\n\nWhen your payer submits this form (don't forget a `<button>` or `<input type=\"submit\">`), he will POST the data directly to the gateway system. There, with minimal interaction with gateway's interface, payment will be processed. In the process, your customer might get redirected to authenticate against 3D Secure system of his card issuer bank (this depends on settings of his card and your account). After that, payer will be taken to `success_redirect` or `failure_redirect` depending on the payment result (as in the usual payment flow).\n\nBe aware, though, that while not having to process card data allows you not to comply with the entirety of PCI DSS SAQ D requirements, having sensitive cardholder data entry form on your website does raise your PCI DSS scope to SAQ A-EP. Contact your account manager to receive advisory and assistance for this integration method.","readOnly":true,"nullable":true,"allOf":[{"type":"string","format":"url","maxLength":500}]},"marked_as_paid":{"type":"boolean","readOnly":true,"description":"True if a purchase was manually marked as paid."},"order_id":{"type":"string","readOnly":true,"description":"ID of corresponding order."}},"allOf":[{"type":"object","properties":{"type":{"type":"string","readOnly":true,"description":"Object type identifier"},"id":{"type":"string","format":"uuid","readOnly":true},"created_on":{"readOnly":true,"description":"Object creation time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]},"updated_on":{"readOnly":true,"description":"Object last modification time","allOf":[{"type":"integer","format":"Unix timestamp (seconds)","example":1619740800}]}}}]}}}},"404":{"description":"No such object"}},"description":"Will set `is_recurring_token` to `false`. You won't be able to use this Purchase's ID as a `recurring_token` anymore. The respective ClientRecurringToken, if any, will also be deleted.\n\nIf this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 a corresponding Webhook callback for a `purchase.pending_recurring_token_delete` event. To be notified of a successful operation completion, please subscribe to `purchase.recurring_token_deleted` callback event.","tags":["Purchases"],"parameters":[{"name":"id","required":true,"in":"path","description":"Object ID (UUID)","schema":{"type":"string","format":"uuid"}}],"method":"post","path":"/purchases/{id}/delete_recurring_token/","servers":[{"url":"/api/v1"}],"info":{"title":"Public REST API","version":"v1","description":"All the endpoints below have a prefix of `https://gate.dineropay.com/api/v1/` (e.g. `POST https://gate.dineropay.com/api/v1/purchases/`).\n\nYou will need your API key that you can obtain in the Developers section in your account. Please use this key as a bearer token in the Authorization header included in every request: `Authorization: Bearer <secret key>`.\n\nBefore starting the development, we recommend checking out the list of ready-to-go connectors to the popular platforms we’ve already built for you. It might save you some precious time if you use one of these to develop your project.\n\nPlugins: [WooCommerce](https://gate.dineropay.com/apis/plugins/WooCommerce%20v3.5+), [OpenCart](https://gate.dineropay.com/apis/plugins/OpenCart%20v3.0+), [Magento](https://gate.dineropay.com/apis/plugins/Magento%20v2.0+), [PrestaShop](https://gate.dineropay.com/apis/plugins/PrestaShop%20v1.7+)\n\n\n\nLibraries: [PHP](https://gate.dineropay.com/apis/libraries/PHP), [Java](https://gate.dineropay.com/apis/libraries/Java), [C#](https://gate.dineropay.com/apis/libraries/C%23), [Node.js](https://gate.dineropay.com/apis/libraries/Node.js)\n\nSDKs: [iOS](https://gate.dineropay.com/apis/sdks/iOS), [Android](https://gate.dineropay.com/apis/sdks/Android)\n***\n\n# Online Purchases\n\n## Prebuilt payment flow — Redirect\n\nRedirect integration allows running payments using the prebuilt payment flow.\n\nTo accept payments in your application or website via redirect, use `POST /purchases/` request to create the `Purchase` and receive the `checkout_url`. Redirect the customer to the `checkout_url` to enter their card details for processing. After the payment is processed, the system will redirect the customer back to your website (take note of `success_redirect`, `failure_redirect`).\n\n*You have three options to check payment status:*\n\n1. Use `success_callback` parameter of the `Purchase` object.\n\n2. Use `GET /purchases/<purchase_id>/` request.\n\n3. Set up a Webhook using the Developers section of your account or use Webhook API to listen to `purchase.paid`, or `purchase.payment_failure` event on your server.\n\nSetting the `skip_capture` flag to `true` allows you to separate the authentication and payment execution steps, allowing you to reserve funds on the customer's card account for some time.\n\nThis flag can also enable preauthorization capability, allowing you to save the card without a financial transaction, if possible.\n\nIf the customer agrees to store his card for future purchases, there will be an option to pay with a single click next time. To enable this, create a `Client` object for each of your clients and provide `client_id` parameter value in your Purchase creation requests.\n\nTo create a Purchase or a BillingTemplate, you must specify the `Brand ID` and `API key`. You can find both in the Developers section of your account.\n\n\n\n## Custom payment flow — Direct Post\n\nDirect post integration allows running payments through the custom payment flow.\n\nTo accept payments in your application or website, use `POST /purchases/` request to create a `Purchase`.\n\nTo capture customers card details use an HTML `<form>` hosted on your website with `method=\"POST\"` and `action` pointing to the `direct_post_url` of the transaction.\n\nYou will also need to fill the form with `<input>`'s for the fields with card details. As a result, when a customer submits their card details, it will be posted straight to our system, allowing you to customize the checkout as you wish. At the same time, your PCI DSS requirement is only raised to Self-Assessment Questionnaire (SAQ A-EP), as your system doesn't receive or process card data.\n\nFor more details, see the documentation on Purchase's `direct_post_url` field.\n\n### Tokenization & recurring payments\n\nYou can store card tokens and charge the respective cards without user interaction if the payment channel supports tokenization.\n\nWhen you pass `remember_card=on` to `direct_post_url`, the respective `Purchase`'s ID will serve as a card token. This initial `Purchase` will have the `is_recurring_token` field set to `true`.\n\nTo charge the tokenized card once again, create a new Purchase and then call the `POST /purchases/{new_purchase_id}/charge/`. In the request body, provide `\"recurring_token\": \"initial_purchase_id\"`. When the request succeeds (response code `200`), the new Purchase will become paid. The token will be persisted in the Purchase's recurring_token field.\n\nUse `\"recurring_token\": \"initial_purchase_id\"` in all the upcoming `POST /purchases/{new_purchase_id}/charge/` requests.\n\nIf you wish to delete the recurring token stored for the initial `Purchase`, use the `POST /purchases/{initial_purhcase_id}/delete_recurring_token/` request. Its `is_recurring_token` will reset to `false`. \n\n## Custom payment flow — Server-to-Server\n\nServer-to-Server (\"S2S\") integration allows running payments on the server level without direct interaction between the client’s browser or application and API.\n\nYou can build an integration that prevents payers from accessing platform resources directly. In this flow, 3D Secure implementation allows API clients to:\n\nCheck 3D Secure enrolment, and if the card is enrolled, receive ACS URL together with all the necessary params for redirection to ACS (PaReq, MD);\nRedirect the payer to the ACS system of their issuer bank;\nReceive the payer back and execute the authorization with a separate request.\n\nIf the card is not enrolled in 3D Secure, authorization will execute synchronously.\n\nPlease note that 3DSv2 which is now the industry standard is fully supported by the S2S flow. While PaReq/PaRes below are 3DSv1 parameters (replaced by creq/cres in 3DSv2 challenge), in case of 3DSv2 proxy ACS solution (where the system is accepting the cardholder navigation using 3DSv1 flow and is performing all parts of 3DSv2 verification and challenge on behalf of merchant) is implemented to maintain API compatibility for older integrations.\n\nTo accept payments in your application or website via S2S:\n\n1.  Ensure the Purchase is created as described in Custom payment flow — Direct Post. As per the Purchase's direct_post_url field description, you will need to ensure all the necessary criteria are met, including success_redirect/failure_redirect fields defined for Purchase and set to arbitrary valid URLs (they will not receive any redirects in the S2S scenario);\n2.  Implement the following request in your server code, appending \"?s2s=true\" to direct_post_url to form the resulting endpoint (you can obtain the S2S token value from your account manager):\n\n        POST {direct_post_url}?s2s=true\n\n    Specify the following headers:\n\n        Content-Type: application/json\n        Authorization: Bearer {S2S token}\n\n    In the request body, provide the following data in JSON (you can omit some of the fields, then system will use default values; We recommend providing correct values from the user’s browser as it can affect 3D Secure success rate):\n\n        {\n          \"cardholder_name\": \"John Doe\",\n          \"card_number\": \"4444333322221111\",\n          \"expires\": \"01/23\",\n          \"cvc\": \"123\",\n          \"remember_card\": \"on\",\n          \"remote_ip\": \"8.8.8.8\",\n          \"user_agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36\",\n          \"accept_header\": \"text/html\",\n          \"language\": \"en-US\",\n          \"java_enabled\": false,\n          \"javascript_enabled\": true,\n          \"color_depth\": 24,\n          \"utc_offset\": 0,\n          \"screen_width\": 1920,\n          \"screen_height\": 1080\n        }\n\n    |Field name&nbsp;|Required&nbsp;|Validation criteria/remarks&nbsp;|Default value|\n    |--- |--- |---|--- |\n    |cardholder_name|Y|Latin letters only (space and apostrophe ('), dot (.), dash (-) symbols are also allowed), max 30 characters||\n    |card_number|Y|text, digits only, no whitespace, max 19 characters||\n    |expires|Y|text in 'MM/YY' format, digits and a slash only (/^\\\\d{2}\\\\/\\\\d{2}$/), max 5 characters||\n    |cvc|Y|numeric string of 3 or 4 digits||\n    |remember_card|N|literal value \"on\" to save card, any other string otherwise||\n    |remote_ip|Y|external IP of payer’s browser in IPv4 or IPv6 format||\n    |user_agent|N|User-Agent as sent by the payer’s browser, max 2048 charge|Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/ 537.36 (KHTML, like Gecko) Chrome/ 88.0.4324.96 Safari/ 537.36|\n    |accept_header|N|Same as above, max 2048 characters|text/html|\n    |language|N|Same as above, max 8 characters|en-US|\n    |java_enabled|N|boolean|false|\n    |javascript_enabled|N|boolean|true|\n    |color_depth|N|integer in 0-255 range|24|\n    |utc_offset|N|integer in -32,768 to 32,767 range|0|\n    |screen_width|N|integer in uint64 range|1920|\n    |screen_height|N|integer in uint64 range|1080|\n\n3.  If the card is not enrolled in 3S Secure, then a response will contain the field \"status\" with one of the following values:\n\"executed\" in case of a successful payment authorization;\n\"authorized\" in case fund reservation using Purchase.skip_capture was requested;\n\"error\" in case of an authorization error.\n\n    Example:\n\n        {\"status\": \"executed\"}\n\n    You will receive \"executed\" or \"authorized\" statuses with a response status code 200 and \"error\" status - with a status code of 400.\n\n    In all of those cases, it is necessary to set up webhooks for purchase events (`purchase.paid, purchase.payment_failure` at least) to receive further information about the status of the financial transaction.\n\n4.  If the card is enrolled in 3D Secure, the response will have a status code of 200, the status will be 3DS_required, and the response will contain additional fields:\n\n        {\n          \"status\": \"3DS_required\",\n          \"Method\": \"(POST|GET)\",\n          \"PaReq\": \"...\",\n          \"MD\": \"... (can arrive empty)\",\n          \"URL\": \"http://url.of.acs.bank/\",\n          \"callback_url\": \"https://...\"\n        }\n\n    It’s necessary to ensure your client’s browser makes a request with the method specified in `Method` (GET or POST only) to the ACS of issuer bank returned in \"URL\", including the values of `MD` and `PaReq` as received (use query params in case of GET and request body params in case of POST). Be aware that MD might arrive empty – in that case, you can send it further as an empty string.\n\n    In addition to those, you also **need to include the `TermUrl` parameter** in the client’s browser request, pointing to the URL in your system where the customer’s navigation will be expected. Once the payer approves the transaction, he will be redirected using the POST method to that URL with `MD` and `PaRes` params in the request body.\n\n5.  Once the client is back to `TermUrl` in your system and you have received the `MD` and `PaRes`, it’s needed to transmit them to the platform to complete the authorization. Send the following request from your server code (no auth headers required):\n\n        POST {callback_url from step 4.}\n\n        Content-Type: application/x-www-form-urlencoded\n        MD={MD received, if any}&PaRes={PaRes received}\n\n    The response will contain the authorization status in JSON format and will be identical to the format described in the previous section.\n\n## Testing Integration\n\nIt’s possible to test-drive all checkouts using a test Purchase.\n\nFor a successful payment, you can use the following card numbers:\n\n*   4444 3333 2222 1111 - non-3D Secure card\n*   5555 5555 5555 4444 - 3D Secure card\n\nFor both cards, please use:\n\n*   any cardholder name\n*   any expiry larger or equal to the current month/year\n*   CVC = 123\n\nFor a failed payment, please change the CVC or expiration date.\n\nWhen using a 3D Secure enrolled card in S2S checkout,  an incorrect CVC will trigger an authorization failure on the S2S callback step (after the customer returns from test ACS). Using a wrong expiry date emulates data validation failure and results in immediate error before that step.\n\n\n***\n\n# Billing\n\n## Invoicing\n\nTo send one-off invoices, use `POST /billing/` request. It's similar to `POST /purchases/` except that customers are an array, allowing you to bulk-issue invoices to several customers at once.\n\nTo send invoices using a template, use a separate `POST /billing_templates/` request (without `clients`!). Then, for each of your clients, use `POST /billing_templates/{billing_template_id}/send_invoice/`.\n\nIf the customer agrees to store his card for future purchases, then the next time the option to pay with a single click will appear if the payment channel supports tokenization.\n\n***\n\n## Subscriptions\n\nSubscriptions allow you to automate recurring purchases. You can create a subscription using the same request `POST /billing_templates/` as for invoices. To create a subscription billing template, specify `is_subscription: true` and `subscription_*` fields in `POST /billing_templates/` request body. Then, add subscribers using the `POST /billing_templates/<billing_template_id>/add_subscriber/` request.\n\nIf the payment channel supports tokenization and the customer agreed to store his datafor future purchases, payments will be processed automatically, while the customer will get a receipt for each purchase. Note that whenever a subscription payment fails, your customer will automatically receive an invoice he can pay (and store a new card for upcoming payments in the process). Your system will also receive the `purchase.subscription_charge_failure` webhook event, if configured.\n\nBy default, the system generates invoices and processes subscription payments at the beginning of the billing cycle.\n\nIf you want to send an invoice or charge a customer at the end of the billing cycle, just set `subscription_charge_period_end` to `true` in `POST /billing_templates/` request.\n\nThe API also provides you with an option to give a trial to your customers before enabling paid subscription period. To do that just set `subscription_trial_periods` in `POST /billing_templates/` request.\n\n***\n\n# Callbacks\n\nTwo methods for defining asynchronous callbacks are supported - `Purchase` success callbacks and webhooks.\n\n## Purchase success callbacks\n\n`Purchase` success callbacks are defined by providing a target URL in the `success_callback` field on `Purchase` creation (see [POST /purchases/](#/Purchases/purchases_create)). The system will generate a callback when:\n* a `Purchase` with `skip_capture=false` is successfully paid;\n* a `Purchase` with `skip_capture=true` is successfully captured (see [POST /purchases/{id}/capture/](#/Purchases/purchases_capture));\n* a `Purchase` is successfully paid using a recurring token (see [POST /purchases/{id}/charge/](#/Purchases/purchases_charge));\n\nThese callbacks pass a JSON-encoded `Purchase` as their payload. The payload represents a snapshot of the state of the `Purchase` when the event was created. The payload will include an `event_type` field to indicate which specific event (see [Event schema](#model-Event)) triggered the callback.\n\nThe payload is signed using a company-wide key pair. You can obtain the public key with `GET /public_key/`. See the `Authentication` section below for more details.\n\n## Webhooks\n\nFor creating and modifying webhooks, see the Webhook [CRUD API specification](#operations-tag-Webhooks).\n\n`Webhook` callback payloads are signed using a dedicated key pair. You can obtain the public key from `Webhook.public_key`. See the [Authentication](#callback-auth) section below for more details.\n\n## Delivery protocol\n\nWhen a callback is not successfully delivered (received by the target server and responded to with a 200 series HTTP response code), the system will make up to 8 additional attempts at exponentially increasing intervals between attempts. No further delivery attempts will be made if the callback is not successfully delivered 36 hours after triggering.\n\nPlease note that due to the asynchronous nature of network requests, it is possible for a callback delivery confirmation (HTTP response with a 200 series status code) to not properly arrive from the callback's target server. Therefore it is possible in case of severe network faults for the target server to receive a callback, respond to it with a 200 series HTTP status code and then receive the same callback after an interval.\n\nCallback deliveries are guaranteed to be sequential to events triggered on their source objects. For example, when registering webhooks for both the `purchase.created` and `purchase.paid` events, there will be no `purchase.paid` callbacks for this `Purchase` until all `purchase.created` callbacks for this `Purchase` are successfully delivered.\n\n## <b id=\"callback-auth\">Authentication</b>\n\nPayloads are signed using asymmetric A.K.A. public-key cryptography to guarantee the authenticity of delivered callbacks. Each callback delivery request includes an X-Signature header field. This field contains a base64-encoded RSA PKCS#1 v1.5 signature of the SHA256 digest of the request body buffer.\n\nYou can obtain the public key for `Webhook` authentication from `Webhook.public_key` of the corresponding `Webhook`.\n\nYou can obtain the public key for success callback authentication from [GET /public_key/](#operations-Public_Key-public_key).\n\nPlease note the provider is not responsible for any financial losses incurred due to not implementing payload signature verification.\n"},"postman":{"name":"Delete a recurring token associated with a purchase.","description":{"content":"Will set `is_recurring_token` to `false`. You won't be able to use this Purchase's ID as a `recurring_token` anymore. The respective ClientRecurringToken, if any, will also be deleted.\n\nIf this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 a corresponding Webhook callback for a `purchase.pending_recurring_token_delete` event. To be notified of a successful operation completion, please subscribe to `purchase.recurring_token_deleted` callback event.","type":"text/plain"},"url":{"path":["purchases",":id","delete_recurring_token",""],"host":["{{baseUrl}}"],"query":[],"variable":[{"disabled":false,"description":{"content":"(Required) Object ID (UUID)","type":"text/plain"},"type":"any","value":"","key":"id"}]},"header":[{"key":"Accept","value":"application/json"}],"method":"POST"}}
sidebar_class_name: "post api-method"
info_path: docs/petstore/public-rest-api
custom_edit_url: null
---

import ApiTabs from "@theme/ApiTabs";
import MimeTabs from "@theme/MimeTabs";
import ParamsItem from "@theme/ParamsItem";
import ResponseSamples from "@theme/ResponseSamples";
import SchemaItem from "@theme/SchemaItem";
import SchemaTabs from "@theme/SchemaTabs";
import DiscriminatorTabs from "@theme/DiscriminatorTabs";
import TabItem from "@theme/TabItem";

## Delete a recurring token associated with a purchase.



Will set `is_recurring_token` to `false`. You won't be able to use this Purchase's ID as a `recurring_token` anymore. The respective ClientRecurringToken, if any, will also be deleted.

If this operation takes too long to be processed on the acquirer side - you will get a response with status code 200 a corresponding Webhook callback for a `purchase.pending_recurring_token_delete` event. To be notified of a successful operation completion, please subscribe to `purchase.recurring_token_deleted` callback event.

<details style={{"marginBottom":"1rem"}} data-collapsed={false} open={true}><summary style={{}}><strong>Path Parameters</strong></summary><div><ul><ParamsItem className={"paramsItem"} param={{"name":"id","required":true,"in":"path","description":"Object ID (UUID)","schema":{"type":"string","format":"uuid"}}}></ParamsItem></ul></div></details><div><ApiTabs><TabItem label={"200"} value={"200"}><div>

OK

</div><div><MimeTabs schemaType={"response"}><TabItem label={"application/json"} value={"application/json"}><SchemaTabs><TabItem label={"Schema"} value={"Schema"}><details style={{}} data-collapsed={false} open={true}><summary style={{"textAlign":"left"}}><strong>Schema</strong></summary><div style={{"textAlign":"left","marginLeft":"1rem"}}></div><ul style={{"marginLeft":"1rem"}}><SchemaItem collapsible={false} name={"type"} required={false} deprecated={undefined} schemaDescription={"Object type identifier"} schemaName={"string"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"id"} required={false} deprecated={undefined} schemaDescription={undefined} schemaName={"uuid"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"created_on"} required={false} deprecated={undefined} schemaDescription={"Object creation time"} schemaName={"Unix timestamp (seconds)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem><SchemaItem collapsible={false} name={"updated_on"} required={false} deprecated={undefined} schemaDescription={"Object last modification time"} schemaName={"Unix timestamp (seconds)"} qualifierMessage={undefined} defaultValue={undefined}></SchemaItem></ul></details></TabItem><TabItem label={"Example (from schema)"} value={"Example (from schema)"}><ResponseSamples responseExample={"{\n  \"type\": \"string\",\n  \"id\": \"3fa85f64-5717-4562-b3fc-2c963f66afa6\",\n  \"created_on\": 1619740800,\n  \"updated_on\": 1619740800\n}"} language={"json"}></ResponseSamples></TabItem></SchemaTabs></TabItem></MimeTabs></div></TabItem><TabItem label={"404"} value={"404"}><div>

No such object

</div><div></div></TabItem></ApiTabs></div>
      